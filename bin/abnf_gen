#!/usr/bin/env node
"use strict";

const abnf = require("../lib/abnf");
const ast = require("../lib/ast");
const { Command } = require("commander");
const path = require("path");
const fs = require("fs");

function readStream(s) {
  return new Promise((resolve, reject) => {
    const bufs = [];
    s.on("error", reject);
    s.on("data", d => bufs.push(d));
    s.on("end", () => resolve(Buffer.concat(bufs).toString("utf8")));
  });
}

function gen_peggy(rules, opts) {
  const out = rules.toPeggy(opts);
  if (opts.output === "-") {
    console.log(out);
  } else {
    fs.writeFileSync(opts.output, out);
  }
}

const program = new Command();
program
  .argument("[abnfFile...]", "ABNF files to turn into peggy grammars.")
  .option(
    "-s, --startRule <ruleName>",
    "Start rule for peggy grammar.  Defaults to first rule in ABNF grammar."
  )
  .option("--stubs", "Generate stubs for rules that do not exist, rather than failing.")
  .option(
    "-o, --output <file>",
    "Output peggy grammar file name.  Derived from input file name if not specified.",
    "stdin.peggy"
  )
  .option(
    "-u, --unused",
    "Output rules that are not reachable from the start rule"
  )
  .option("-c, --core", "Include core rules from RFC 5234, Appendix B.")
  .action(async(files, opts, cmd) => {
    if (files.length === 0) {
      files.push("-");
      if ((cmd.getOptionValueSource("output") === "default") && opts.core) {
        cmd.setOptionValueWithSource("output", opts.output, "forced");
      }
    }
    if (opts.core) {
      files.push(path.resolve(__dirname, "..", "examples", "core.abnf"));
    }

    let input = "";
    let lines = 0;
    const file_offsets = [];
    for (const f of files) {
      let text = null;
      if (f === "-") {
        text = abnf.formatInput(await readStream(process.stdin));
      } else {
        if (cmd.getOptionValueSource("output") === "default") {
          const p = path.parse(f);
          delete p.base;
          p.ext = ".peggy";
          cmd.setOptionValueWithSource("output", path.format(p), "first");
        }
        text = abnf.formatInput(fs.readFileSync(f, "utf8"));
      }
      const len = text.split("\r\n").length;
      file_offsets.push({
        name: f,
        start: lines,
        end: lines + len,
      });
      lines += len;
      input += text;
    }

    const rules = new ast.Rules();
    try {
      abnf.parseString(rules, input, { strict: true });
    } catch (er) {
      for (const { name, start, end } of file_offsets) {
        if ((rules.line >= start) && (rules.line <= end)) {
          console.error(`In file "${name}" at line ${rules.line - start}`);
          break;
        }
      }
      console.error(er.message);
    }

    gen_peggy(rules, opts);
  })
  .parseAsync()
  .catch(er => {
    console.error(er);
  });
